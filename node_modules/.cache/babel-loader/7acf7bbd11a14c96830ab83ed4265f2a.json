{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { setAPIKey, setEmbedHost, post } from '@toruslabs/http-helpers';\nimport stringify from 'json-stable-stringify';\nimport { ec as ec$1 } from 'elliptic';\nimport createKeccakHash from 'keccak';\nimport { encrypt, getPublic, decrypt } from '@toruslabs/eccrypto';\n\nfunction keccak256(a) {\n  return createKeccakHash(\"keccak256\").update(a).digest();\n}\n\nconst ec = new ec$1(\"secp256k1\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass MetadataStorageLayer {\n  // ms\n  constructor() {\n    let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n    let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _defineProperty(this, \"metadataHost\", void 0);\n\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n\n  generateMetadataParams(message, privateKeyHex) {\n    var _ref, _sig$recoveryParam;\n\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n    };\n    const sig = key.sign(keccak256(stringify(setData)));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from((_ref = sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2))) !== null && _ref !== void 0 ? _ref : \"00\", \"hex\").toString(\"base64\")\n    };\n  }\n\n  generatePubKeyParams(privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\")\n    };\n  }\n\n  async setMetadata(data, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, data), {}, {\n      namespace\n    }) : data;\n    const metadataResponse = await post(\"\".concat(this.metadataHost, \"/set\"), params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n\n  async getMetadata(pubKey, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, pubKey), {}, {\n      namespace\n    }) : pubKey;\n    const metadataResponse = await post(\"\".concat(this.metadataHost, \"/get\"), params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n\n}\n\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\n\nfunction encParamsHexToBuf(encParamsHex) {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\")\n  };\n}\n\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\")\n  };\n}\n\nasync function encryptData(privKeyHex, d) {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await encrypt(getPublic(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\n\nasync function decryptData(privKeyHex, d) {\n  const encParamsHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await decrypt(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data = JSON.parse(serializedDec);\n  return data;\n}\n\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({\n    pub_key_X: pubKey.getX().toString(16),\n    pub_key_Y: pubKey.getY().toString(16)\n  }, namespace);\n\n  if (!serializedData) {\n    return null;\n  }\n\n  const data = await decryptData(privKeyHex, serializedData);\n  return data;\n}\n\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\n\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await encrypt(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\n\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\n\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await decrypt(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\n\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\n\nexport { decryptData, MetadataStorageLayer as default, ec, encParamsBufToHex, encParamsHexToBuf, encryptAndSetData, encryptData, getAndDecryptData, getDeviceShare, getTorusShare, keccak256, setDeviceShare, setTorusShare };","map":{"version":3,"sources":["../src/utils.ts","../src/MetadataStorageLayer.ts","../src/webAuthnShareResolver.ts"],"names":["createKeccakHash","ec","constructor","metadataHost","serverTimeOffset","setAPIKey","setEmbedHost","generateMetadataParams","key","setData","data","timestamp","Math","Date","sig","keccak256","stringify","pub_key_X","pub_key_Y","set_data","signature","Buffer","generatePubKeyParams","setMetadata","params","namespace","metadataResponse","post","useAPIKey","getMetadata","WEBAUTHN_TORUS_SHARE","WEBAUTHN_DEVICE_SHARE","iv","encParamsHex","ephemPublicKey","ciphertext","mac","encParams","serializedDec","JSON","serializedBuf","encrypt","getPublic","encParamsBufToHex","sData","encParamsHexToBuf","keyPair","decrypt","pubKey","serializedData","decryptData","encryptData","metadataParams","m","refKeyPair","privKey","x","webAuthnPubKey","y","getAndDecryptData","d","serializedSubspaceData","serializedSubspaceDataBuf","encSubspaceData","encSubspaceDataHex","encryptAndSetData","subspaceData"],"mappings":";;;;;;;AAGM,SAAA,SAAA,CAAA,CAAA,EAAsC;AACnCA,SAAAA,gBAAgB,CAAhBA,WAAgB,CAAhBA,CAAAA,MAAAA,CAAAA,CAAAA,EAAP,MAAOA,EAAAA;AACR;;MAEYC,EAAE,GAAG,IAAA,IAAA,CAAA,WAAA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACWlB,MAAA,oBAAA,CAA0B;AAGS;AAEjCC,EAAAA,WAAAA,GAA0E;AAA9DC,QAAAA,YAA8D,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAA/C,yBAAfA;AAA0CC,QAAAA,gBAAoB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAD,CAAnBA;;AAAoB,IAAA,eAAA,CAAA,IAAA,EAAA,cAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,kBAAA,EAAA,KAAA,CAAA,CAAA;;AACnED,SAAL,YAAKA,GAAL,YAAKA;AACAC,SAAL,gBAAKA,GAAL,gBAAKA;AACN;;AAEe,SAATC,SAAS,CAAA,MAAA,EAAe;AAC7BA,IAAAA,SAAS,CAATA,MAAS,CAATA;AACD;;AAEkB,SAAZC,YAAY,CAAA,SAAA,EAAkB;AACnCA,IAAAA,YAAY,CAAZA,SAAY,CAAZA;AACD;;AAEDC,EAAAA,sBAAsB,CAAA,OAAA,EAAA,aAAA,EAAuC;AAAA,QAAA,IAAA,EAAA,kBAAA;;AACrDC,UAAAA,GAAG,GAAGP,EAAE,CAAFA,cAAAA,CAAAA,aAAAA,EAAZ,KAAYA,CAANO;AACN,UAAMC,OAAO,GAAG;AACdC,MAAAA,IAAI,EADU,OAAA;AAEdC,MAAAA,SAAS,EAAEC,IAAI,CAAJA,KAAAA,CAAW,KAAA,gBAAA,GAAwBC,IAAI,CAAJA,GAAAA,KAAnCD,IAAAA,EAAAA,QAAAA,CAAAA,EAAAA;AAFG,KAAhB;AAIA,UAAME,GAAG,GAAGN,GAAG,CAAHA,IAAAA,CAASO,SAAS,CAACC,SAAS,CAAxC,OAAwC,CAAV,CAAlBR,CAAZ;AACO,WAAA;AACLS,MAAAA,SAAS,EAAET,GAAG,CAAHA,SAAAA,GAAAA,IAAAA,GAAAA,QAAAA,CADN,KACMA,CADN;AAELU,MAAAA,SAAS,EAAEV,GAAG,CAAHA,SAAAA,GAAAA,IAAAA,GAAAA,QAAAA,CAFN,KAEMA,CAFN;AAGLW,MAAAA,QAAQ,EAHH,OAAA;AAILC,MAAAA,SAAS,EAAEC,MAAM,CAANA,IAAAA,CAAAA,CAAAA,IAAAA,GACTP,GAAG,CAAHA,CAAAA,CAAAA,QAAAA,CAAAA,EAAAA,EAAAA,EAAAA,IAAyBA,GAAG,CAAHA,CAAAA,CAAAA,QAAAA,CAAAA,EAAAA,EAAzBA,EAAyBA,CAAzBA,IAAAA,CAAAA,kBAAAA,GAAkDA,GAAG,CAArDA,aAAAA,MAAkDA,IAAlDA,IAAkDA,kBAAAA,KAAAA,KAAAA,CAAlDA,GAAkDA,KAAAA,CAAlDA,GAAkDA,kBAAAA,CAAAA,QAAAA,CAAAA,EAAAA,EAAAA,QAAAA,CAAAA,CAAAA,EAAAA,GAAAA,EAAAA,KAAAA,CAAuD,CADhGO,CACyCP,CAAlDA,CADSO,MAAAA,IAAAA,IAAAA,IAAAA,KAAAA,KAAAA,CAAAA,GAAAA,IAAAA,GAAAA,IAAAA,EAAAA,KAAAA,EAAAA,QAAAA,CAAAA,QAAAA;AAJN,KAAA;AASR;;AAEDC,EAAAA,oBAAoB,CAAA,aAAA,EAAsB;AAClCd,UAAAA,GAAG,GAAGP,EAAE,CAAFA,cAAAA,CAAAA,aAAAA,EAAZ,KAAYA,CAANO;AACC,WAAA;AACLS,MAAAA,SAAS,EAAET,GAAG,CAAHA,SAAAA,GAAAA,IAAAA,GAAAA,QAAAA,CADN,KACMA,CADN;AAELU,MAAAA,SAAS,EAAEV,GAAG,CAAHA,SAAAA,GAAAA,IAAAA,GAAAA,QAAAA,CAAAA,KAAAA;AAFN,KAAA;AAIR;;AAEgB,QAAXe,WAAW,CAAA,IAAA,EAAA,SAAA,EAAA,OAAA,EAAsE;AACrF,UAAMC,MAAM,GAAG,SAAS,KAAT,IAAA,GAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,IAAA,CAAA,EAAA,EAAA,EAAA;AAAgCC,MAAAA;AAAhC,KAAA,CAAA,GAAf,IAAA;AACMC,UAAAA,gBAAgB,GAAG,MAAMC,IAAI,CAAA,GAAA,MAAA,CAAyB,KAAzB,YAAA,EAAkDH,MAAlD,CAAA,EAAA,MAAA,EAAA,OAAA,EAAmE;AAAEI,MAAAA,SAAS,EAAE;AAAb,KAAnE,CAA7BF;AACCA,WAAAA,gBAAgB,CAAvB,OAAOA;AACR;;AAEgB,QAAXG,WAAW,CAAA,MAAA,EAAA,SAAA,EAAA,OAAA,EAAsE;AACrF,UAAML,MAAM,GAAG,SAAS,KAAT,IAAA,GAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,MAAA,CAAA,EAAA,EAAA,EAAA;AAAkCC,MAAAA;AAAlC,KAAA,CAAA,GAAf,MAAA;AACMC,UAAAA,gBAAgB,GAAG,MAAMC,IAAI,CAAA,GAAA,MAAA,CAAyB,KAAzB,YAAA,EAAkDH,MAAlD,CAAA,EAAA,MAAA,EAAA,OAAA,EAAmE;AAAEI,MAAAA,SAAS,EAAE;AAAb,KAAnE,CAA7BF;AACCA,WAAAA,gBAAgB,CAAvB,OAAOA;AACR;;AAtDuB;;ACb1B,MAAMI,oBAAoB,GAA1B,sBAAA;AACA,MAAMC,qBAAqB,GAA3B,uBAAA;;AASM,SAAA,iBAAA,CAAA,YAAA,EAAkD;AAC/C,SAAA;AACLC,IAAAA,EAAE,EAAEX,MAAM,CAANA,IAAAA,CAAYY,YAAY,CAAxBZ,EAAAA,EADC,KACDA,CADC;AAELa,IAAAA,cAAc,EAAEb,MAAM,CAANA,IAAAA,CAAYY,YAAY,CAAxBZ,cAAAA,EAFX,KAEWA,CAFX;AAGLc,IAAAA,UAAU,EAAEd,MAAM,CAANA,IAAAA,CAAYY,YAAY,CAAxBZ,UAAAA,EAHP,KAGOA,CAHP;AAILe,IAAAA,GAAG,EAAEf,MAAM,CAANA,IAAAA,CAAYY,YAAY,CAAxBZ,GAAAA,EAAAA,KAAAA;AAJA,GAAA;AAMR;;AAEK,SAAA,iBAAA,CAAA,SAAA,EAA4C;AACzC,SAAA;AACLW,IAAAA,EAAE,EAAEX,MAAM,CAANA,IAAAA,CAAYgB,SAAS,CAArBhB,EAAAA,EAAAA,QAAAA,CADC,KACDA,CADC;AAELa,IAAAA,cAAc,EAAEb,MAAM,CAANA,IAAAA,CAAYgB,SAAS,CAArBhB,cAAAA,EAAAA,QAAAA,CAFX,KAEWA,CAFX;AAGLc,IAAAA,UAAU,EAAEd,MAAM,CAANA,IAAAA,CAAYgB,SAAS,CAArBhB,UAAAA,EAAAA,QAAAA,CAHP,KAGOA,CAHP;AAILe,IAAAA,GAAG,EAAEf,MAAM,CAANA,IAAAA,CAAYgB,SAAS,CAArBhB,GAAAA,EAAAA,QAAAA,CAAAA,KAAAA;AAJA,GAAA;AAMR;;AAEM,eAAA,WAAA,CAAA,UAAA,EAAA,CAAA,EAAyD;AAC9D,QAAMiB,aAAa,GAAGC,IAAI,CAAJA,SAAAA,CAAtB,CAAsBA,CAAtB;AACMC,QAAAA,aAAa,GAAGnB,MAAM,CAANA,IAAAA,CAAAA,aAAAA,EAAtB,OAAsBA,CAAhBmB;AACN,QAAMH,SAAS,GAAG,MAAMI,OAAO,CAACC,SAAS,CAACrB,MAAM,CAANA,IAAAA,CAAAA,UAAAA,EAAX,KAAWA,CAAD,CAAV,EAA/B,aAA+B,CAA/B;AACA,QAAMY,YAAY,GAAGU,iBAAiB,CAAtC,SAAsC,CAAtC;AACA,QAAMC,KAAK,GAAGL,IAAI,CAAJA,SAAAA,CAAd,YAAcA,CAAd;AACA,SAAA,KAAA;AACD;;AAEM,eAAA,WAAA,CAAA,UAAA,EAAA,CAAA,EAA2D;AAChE,QAAMN,YAAY,GAAaM,IAAI,CAAJA,KAAAA,CAA/B,CAA+BA,CAA/B;AACA,QAAMF,SAAS,GAAGQ,iBAAiB,CAAnC,YAAmC,CAAnC;AACA,QAAMC,OAAO,GAAG7C,EAAE,CAAFA,cAAAA,CAAhB,UAAgBA,CAAhB;AACMuC,QAAAA,aAAa,GAAG,MAAMO,OAAO,CAAC1B,MAAM,CAANA,IAAAA,CAAYyB,OAAO,CAAPA,UAAAA,GAAAA,QAAAA,CAAAA,KAAAA,EAAZzB,EAAYyB,CAAZzB,EAAD,KAACA,CAAD,EAAnC,SAAmC,CAA7BmB;AACN,QAAMF,aAAa,GAAGE,aAAa,CAAbA,QAAAA,CAAtB,OAAsBA,CAAtB;AACA,QAAM9B,IAAI,GAAM6B,IAAI,CAAJA,KAAAA,CAAhB,aAAgBA,CAAhB;AACA,SAAA,IAAA;AACD;;AAEM,eAAA,iBAAA,CAAA,CAAA,EAAA,UAAA,EAAA,SAAA,EAAkG;AACvG,QAAMO,OAAO,GAAG7C,EAAE,CAAFA,cAAAA,CAAhB,UAAgBA,CAAhB;AACA,QAAM+C,MAAM,GAAGF,OAAO,CAAtB,SAAeA,EAAf;AACA,QAAMG,cAAc,GAAG,MAAM,CAAC,CAAD,WAAA,CAAc;AAAEhC,IAAAA,SAAS,EAAE+B,MAAM,CAANA,IAAAA,GAAAA,QAAAA,CAAb,EAAaA,CAAb;AAAyC9B,IAAAA,SAAS,EAAE8B,MAAM,CAANA,IAAAA,GAAAA,QAAAA,CAAAA,EAAAA;AAApD,GAAd,EAA7B,SAA6B,CAA7B;;AACI,MAAA,CAAJ,cAAI,EAAiB;AACnB,WAAA,IAAA;AACD;;AACKtC,QAAAA,IAAI,GAAG,MAAMwC,WAAW,CAAA,UAAA,EAA9B,cAA8B,CAAxBxC;AACN,SAAA,IAAA;AACD;;AAEM,eAAA,iBAAA,CAAA,CAAA,EAAA,UAAA,EAAA,CAAA,EAAA,SAAA,EAA2H;AAC1HkC,QAAAA,KAAK,GAAG,MAAMO,WAAW,CAAA,UAAA,EAA/B,CAA+B,CAAzBP;AACAQ,QAAAA,cAAc,GAAGC,CAAC,CAADA,sBAAAA,CAAAA,KAAAA,EAAvB,UAAuBA,CAAjBD;AACN,QAAMC,CAAC,CAADA,WAAAA,CAAAA,cAAAA,EAAN,SAAMA,CAAN;AACD;;AAEM,eAAA,aAAA,CAAA,CAAA,EAAA,cAAA,EAAA,cAAA,EAAA,QAAA,EAAA,YAAA,EAKgB;AAErB,QAAMC,UAAU,GAAGrD,EAAE,CAAFA,cAAAA,CAAnB,cAAmBA,CAAnB;AACA,QAAMsD,OAAO,GAAGD,UAAU,CAA1B,UAAgBA,EAAhB;AACA,QAAMN,MAAM,GAAG,EAAE,CAAF,aAAA,CAAiB;AAC9BQ,IAAAA,CAAC,EAAEC,cAAc,CADa,SAAA;AAE9BC,IAAAA,CAAC,EAAED,cAAc,CAACvC;AAFY,GAAjB,CAAf;AAIMR,QAAAA,IAAI,GAAG,MAAMiD,iBAAiB,CAAA,CAAA,EAAA,cAAA,EAApC,oBAAoC,CAA9BjD;AACFkD,MAAAA,CAAC,GAAL,EAAIA;AACJ,MAAA,IAAA,EAAUA,CAAC,GAADA,IAAAA;AACV,QAAMC,sBAAsB,GAAGtB,IAAI,CAAJA,SAAAA,CAA/B,YAA+BA,CAA/B;AACMuB,QAAAA,yBAAyB,GAAGzC,MAAM,CAANA,IAAAA,CAAAA,sBAAAA,EAAlC,OAAkCA,CAA5ByC;AACAC,QAAAA,eAAe,GAAG,MAAMtB,OAAO,CAACpB,MAAM,CAANA,IAAAA,CAAY2B,MAAM,CAANA,SAAAA,CAAZ3B,KAAY2B,CAAZ3B,EAAD,KAACA,CAAD,EAArC,yBAAqC,CAA/B0C;AACN,QAAMC,kBAAkB,GAAGrB,iBAAiB,CAA5C,eAA4C,CAA5C;AACAiB,EAAAA,CAAC,CAADA,QAAC,CAADA,GAAAA,kBAAAA;AACA,QAAMK,iBAAiB,CAAA,CAAA,EAAIV,OAAO,CAAPA,QAAAA,CAAAA,KAAAA,EAAJ,EAAIA,CAAJ,EAAA,CAAA,EAAvB,oBAAuB,CAAvB;AACD;;AAEM,eAAA,cAAA,CAAA,CAAA,EAAA,cAAA,EAAA,QAAA,EAAA,YAAA,EAAsH;AAC3H,QAAMT,OAAO,GAAG7C,EAAE,CAAFA,cAAAA,CAAhB,cAAgBA,CAAhB;AACA,QAAMsD,OAAO,GAAGT,OAAO,CAAvB,UAAgBA,EAAhB;AACMpC,QAAAA,IAAI,GAAG,MAAMiD,iBAAiB,CAAA,CAAA,EAAA,cAAA,EAApC,qBAAoC,CAA9BjD;AACFkD,MAAAA,CAAC,GAAL,EAAIA;AACJ,MAAA,IAAA,EAAUA,CAAC,GAADA,IAAAA;AACVA,EAAAA,CAAC,CAADA,QAAC,CAADA,GAAAA,YAAAA;AACA,QAAMK,iBAAiB,CAAA,CAAA,EAAIV,OAAO,CAAPA,QAAAA,CAAAA,KAAAA,EAAJ,EAAIA,CAAJ,EAAA,CAAA,EAAvB,qBAAuB,CAAvB;AACD;;AAEM,eAAA,aAAA,CAAA,CAAA,EAAA,cAAA,EAAA,cAAA,EAAA,QAAA,EAAyH;AACxH7C,QAAAA,IAAI,GAAG,MAAMiD,iBAAiB,CAAA,CAAA,EAAA,cAAA,EAApC,oBAAoC,CAA9BjD;AACN,MAAI,CAAJ,IAAA,EAAW,OAAA,IAAA;AACX,QAAMuB,YAAY,GAAGvB,IAAI,CAAzB,QAAyB,CAAzB;AACA,MAAI,CAAJ,YAAA,EAAmB,OAAA,IAAA;AACnB,QAAM2B,SAAS,GAAGQ,iBAAiB,CAAnC,YAAmC,CAAnC;AACA,QAAMC,OAAO,GAAG7C,EAAE,CAAFA,cAAAA,CAAhB,cAAgBA,CAAhB;AACA,QAAMsD,OAAO,GAAGT,OAAO,CAAvB,UAAgBA,EAAhB;AACMgB,QAAAA,yBAAyB,GAAG,MAAMf,OAAO,CAAC1B,MAAM,CAANA,IAAAA,CAAYkC,OAAO,CAAPA,QAAAA,CAAAA,KAAAA,EAAZlC,EAAYkC,CAAZlC,EAAD,KAACA,CAAD,EAA/C,SAA+C,CAAzCyC;AACN,QAAMD,sBAAsB,GAAGC,yBAAyB,CAAzBA,QAAAA,CAA/B,OAA+BA,CAA/B;AACA,QAAMI,YAAY,GAAG3B,IAAI,CAAJA,KAAAA,CAArB,sBAAqBA,CAArB;AACA,SAAA,YAAA;AACD;;AAEM,eAAA,cAAA,CAAA,CAAA,EAAA,cAAA,EAAA,QAAA,EAAkG;AACjG7B,QAAAA,IAAI,GAAG,MAAMiD,iBAAiB,CAAA,CAAA,EAAA,cAAA,EAApC,qBAAoC,CAA9BjD;AACN,MAAA,IAAA,EAAU,OAAOA,IAAI,CAAX,QAAW,CAAX;AACV,SAAA,IAAA;AACD","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { setAPIKey, setEmbedHost, post } from '@toruslabs/http-helpers';\nimport stringify from 'json-stable-stringify';\nimport { ec as ec$1 } from 'elliptic';\nimport createKeccakHash from 'keccak';\nimport { encrypt, getPublic, decrypt } from '@toruslabs/eccrypto';\n\nfunction keccak256(a) {\n  return createKeccakHash(\"keccak256\").update(a).digest();\n}\nconst ec = new ec$1(\"secp256k1\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass MetadataStorageLayer {\n  // ms\n  constructor() {\n    let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n    let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _defineProperty(this, \"metadataHost\", void 0);\n\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n\n  generateMetadataParams(message, privateKeyHex) {\n    var _ref, _sig$recoveryParam;\n\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n    };\n    const sig = key.sign(keccak256(stringify(setData)));\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n      set_data: setData,\n      signature: Buffer.from((_ref = sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2))) !== null && _ref !== void 0 ? _ref : \"00\", \"hex\").toString(\"base64\")\n    };\n  }\n\n  generatePubKeyParams(privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(\"hex\"),\n      pub_key_Y: key.getPublic().getY().toString(\"hex\")\n    };\n  }\n\n  async setMetadata(data, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, data), {}, {\n      namespace\n    }) : data;\n    const metadataResponse = await post(\"\".concat(this.metadataHost, \"/set\"), params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n\n  async getMetadata(pubKey, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, pubKey), {}, {\n      namespace\n    }) : pubKey;\n    const metadataResponse = await post(\"\".concat(this.metadataHost, \"/get\"), params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n\n}\n\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\")\n  };\n}\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\")\n  };\n}\nasync function encryptData(privKeyHex, d) {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await encrypt(getPublic(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\nasync function decryptData(privKeyHex, d) {\n  const encParamsHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await decrypt(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data = JSON.parse(serializedDec);\n  return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({\n    pub_key_X: pubKey.getX().toString(16),\n    pub_key_Y: pubKey.getY().toString(16)\n  }, namespace);\n\n  if (!serializedData) {\n    return null;\n  }\n\n  const data = await decryptData(privKeyHex, serializedData);\n  return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await encrypt(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await decrypt(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\n\nexport { decryptData, MetadataStorageLayer as default, ec, encParamsBufToHex, encParamsHexToBuf, encryptAndSetData, encryptData, getAndDecryptData, getDeviceShare, getTorusShare, keccak256, setDeviceShare, setTorusShare };\n//# sourceMappingURL=metadataHelpers.esm.js.map\n"]},"metadata":{},"sourceType":"module"}