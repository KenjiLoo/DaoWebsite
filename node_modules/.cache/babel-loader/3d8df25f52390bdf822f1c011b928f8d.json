{"ast":null,"code":"/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet =\n/** @class */\nfunction () {\n  function ObliviousSet(ttl) {\n    this.ttl = ttl;\n    this.map = new Map();\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n\n    this._to = false;\n  }\n\n  ObliviousSet.prototype.has = function (value) {\n    return this.map.has(value);\n  };\n\n  ObliviousSet.prototype.add = function (value) {\n    var _this = this;\n\n    this.map.set(value, now());\n    /**\n     * When a new value is added,\n     * start the cleanup at the next tick\n     * to not block the cpu for more important stuff\n     * that might happen.\n     */\n\n    if (!this._to) {\n      this._to = true;\n      setTimeout(function () {\n        _this._to = false;\n        removeTooOldValues(_this);\n      }, 0);\n    }\n  };\n\n  ObliviousSet.prototype.clear = function () {\n    this.map.clear();\n  };\n\n  return ObliviousSet;\n}();\n\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\n\nexport function removeTooOldValues(obliviousSet) {\n  var olderThen = now() - obliviousSet.ttl;\n  var iterator = obliviousSet.map[Symbol.iterator]();\n  /**\n   * Because we can assume the new values are added at the bottom,\n   * we start from the top and stop as soon as we reach a non-too-old value.\n   */\n\n  while (true) {\n    var next = iterator.next().value;\n\n    if (!next) {\n      return; // no more elements\n    }\n\n    var value = next[0];\n    var time = next[1];\n\n    if (time < olderThen) {\n      obliviousSet.map.delete(value);\n    } else {\n      // We reached a value that is not old enough\n      return;\n    }\n  }\n}\nexport function now() {\n  return new Date().getTime();\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"AACA;;;;AAIG;AACH,IAAA,YAAA;AAAA;AAAA,YAAA;AAQI,WAAA,YAAA,CACoB,GADpB,EAC+B;AAAX,SAAA,GAAA,GAAA,GAAA;AARJ,SAAA,GAAA,GAAM,IAAI,GAAJ,EAAN;AAEhB;;;AAGG;;AACI,SAAA,GAAA,GAAe,KAAf;AAGF;;AAEL,EAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,KAAJ,EAAY;AACR,WAAO,KAAK,GAAL,CAAS,GAAT,CAAa,KAAb,CAAP;AACH,GAFD;;AAIA,EAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,KAAJ,EAAY;AAAZ,QAAA,KAAA,GAAA,IAAA;;AACI,SAAK,GAAL,CAAS,GAAT,CAAa,KAAb,EAAoB,GAAG,EAAvB;AAEA;;;;;AAKG;;AACH,QAAI,CAAC,KAAK,GAAV,EAAe;AACX,WAAK,GAAL,GAAW,IAAX;AACA,MAAA,UAAU,CAAC,YAAA;AACP,QAAA,KAAI,CAAC,GAAL,GAAW,KAAX;AACA,QAAA,kBAAkB,CAAC,KAAD,CAAlB;AACH,OAHS,EAGP,CAHO,CAAV;AAIH;AACJ,GAhBD;;AAkBA,EAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACI,SAAK,GAAL,CAAS,KAAT;AACH,GAFD;;AAGJ,SAAA,YAAA;AAAC,CArCD,EAAA;;;AAwCA;;;AAGG;;AACH,OAAM,SAAU,kBAAV,CACF,YADE,EACwB;AAE1B,MAAM,SAAS,GAAG,GAAG,KAAK,YAAY,CAAC,GAAvC;AACA,MAAM,QAAQ,GAAG,YAAY,CAAC,GAAb,CAAiB,MAAM,CAAC,QAAxB,GAAjB;AAEA;;;AAGG;;AACH,SAAO,IAAP,EAAa;AAET,QAAM,IAAI,GAAG,QAAQ,CAAC,IAAT,GAAgB,KAA7B;;AAEA,QAAI,CAAC,IAAL,EAAW;AACP,aADO,CACC;AACX;;AACD,QAAM,KAAK,GAAG,IAAI,CAAC,CAAD,CAAlB;AACA,QAAM,IAAI,GAAG,IAAI,CAAC,CAAD,CAAjB;;AACA,QAAI,IAAI,GAAG,SAAX,EAAsB;AAClB,MAAA,YAAY,CAAC,GAAb,CAAiB,MAAjB,CAAwB,KAAxB;AACH,KAFD,MAEO;AACH;AACA;AACH;AACJ;AACJ;AAED,OAAM,SAAU,GAAV,GAAa;AACf,SAAO,IAAI,IAAJ,GAAW,OAAX,EAAP;AACH","sourceRoot":"","sourcesContent":["/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet = /** @class */ (function () {\n    function ObliviousSet(ttl) {\n        this.ttl = ttl;\n        this.map = new Map();\n        /**\n         * Creating calls to setTimeout() is expensive,\n         * so we only do that if there is not timeout already open.\n         */\n        this._to = false;\n    }\n    ObliviousSet.prototype.has = function (value) {\n        return this.map.has(value);\n    };\n    ObliviousSet.prototype.add = function (value) {\n        var _this = this;\n        this.map.set(value, now());\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(function () {\n                _this._to = false;\n                removeTooOldValues(_this);\n            }, 0);\n        }\n    };\n    ObliviousSet.prototype.clear = function () {\n        this.map.clear();\n    };\n    return ObliviousSet;\n}());\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(obliviousSet) {\n    var olderThen = now() - obliviousSet.ttl;\n    var iterator = obliviousSet.map[Symbol.iterator]();\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        var next = iterator.next().value;\n        if (!next) {\n            return; // no more elements\n        }\n        var value = next[0];\n        var time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        }\n        else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\nexport function now() {\n    return new Date().getTime();\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}